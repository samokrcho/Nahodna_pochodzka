#include "../common/protocol.h"
#include "../common/simulation.h"
#include "../common/walker.h"
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>

int fd_cmd;
int fd_out;
Simulation *sim;

volatile int running = 1;
volatile SimMode mode = MODE_INTERACTIVE;
volatile int sum_type = 0;
pthread_mutex_t mode_mutex = PTHREAD_MUTEX_INITIALIZER;

void* command_thread(void* arg){
    CommandType cmd;
    while(running){
        if(read(fd_cmd,&cmd,sizeof(cmd))==sizeof(cmd)){
            pthread_mutex_lock(&mode_mutex);
            if(cmd==CMD_MODE_SWITCH)
                mode = (mode==MODE_INTERACTIVE)?MODE_SUMMARY:MODE_INTERACTIVE;
            else if(cmd==CMD_SUM_TYPE_SWITCH && mode==MODE_SUMMARY)
                sum_type = !sum_type;
            else if(cmd==CMD_QUIT) running=0;
            pthread_mutex_unlock(&mode_mutex);
        }
        usleep(50000);
    }
    return NULL;
}

void send_world_state(Walker* w, int step, int rep){
    WorldState ws;
    ws.width = sim->world->width;
    ws.height = sim->world->height;
    ws.walker_x = w->x;
    ws.walker_y = w->y;
    ws.step = step;
    ws.current_rep = rep;
    ws.total_rep = sim->replikacie;
    for(int y=0;y<ws.height;y++)
        for(int x=0;x<ws.width;x++)
            ws.cells[y][x] = sim->world->cells[y][x];

    write(fd_out,&ws,sizeof(ws));
}

void* simulation_thread(void* arg){
    for(int rep=1; rep<=sim->replikacie && running; rep++){
        Walker w = sim->walker;
        send_world_state(&w,0,rep);

        for(int step=1; step<=sim->K && running; step++){
            walker_step(&w, sim->world->width, sim->world->height, sim->world->cells);
            simulation_update_summary(sim,w.x,w.y,step);

            pthread_mutex_lock(&mode_mutex);
            SimMode current_mode = mode;
            pthread_mutex_unlock(&mode_mutex);

            if(current_mode==MODE_INTERACTIVE){
                send_world_state(&w, step, rep);
                usleep(150000);
            }

            if(w.x==0 && w.y==0) break;
        }

        if(running && mode==MODE_SUMMARY){
            for(int y=0;y<sim->world->height;y++)
                for(int x=0;x<sim->world->width;x++){
                    w.x=x; w.y=y;
                    send_world_state(&w,0,rep);
                }
        }
    }

    // uloz simulaciu po ukonceni
    char** cells = malloc(sim->world->height * sizeof(char*));
    for(int y=0;y<sim->world->height;y++){
        cells[y] = malloc(sim->world->width);
        for(int x=0;x<sim->world->width;x++)
            cells[y][x] = sim->world->cells[y][x];
    }

    save_simulation_file(sim->config.output_file, &sim->config, cells);

    for(int y=0;y<sim->world->height;y++) free(cells[y]);
    free(cells);

    running=0;
    return NULL;
}

int main(){
    SimulationConfig cfg;
    read(STDIN_FILENO,&cfg,sizeof(cfg));

    if(cfg.world_type==0) sim = create_simulation(cfg.width,cfg.height,cfg.K,cfg.replikacie);
    else sim = create_simulation_with_obstacles(cfg.width,cfg.height,cfg.K,cfg.replikacie,cfg.obstacle_ratio);

    sim->walker.prob_up=cfg.prob_up;
    sim->walker.prob_down=cfg.prob_down;
    sim->walker.prob_left=cfg.prob_left;
    sim->walker.prob_right=cfg.prob_right;
    sim->walker.x=cfg.width/2;
    sim->walker.y=cfg.height/2;

    fd_cmd=STDIN_FILENO;
    fd_out=STDOUT_FILENO;

    pthread_t sim_th, cmd_th;
    pthread_create(&cmd_th,NULL,command_thread,NULL);
    pthread_create(&sim_th,NULL,simulation_thread,NULL);

    pthread_join(sim_th,NULL);
    pthread_join(cmd_th,NULL);

    destroy_simulation(sim);
    return 0;
}
